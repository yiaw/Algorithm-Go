
# 넓이 우선 탐색 
모든 Node를 탐색 하는 방법 중 하나이다. 주요 풀이 법(Que)

`최단 경로`를 구하는 문제의 경우 BFS로 풀이 한다.

BFS가 최단 경로인 이유는 
현재 위치에서 연결된 모든 노드들을 탐색 한다. (LEVEL)

아래의 그림처럼 각각의 거리가1인 그래프가 존재한다고 가정하자 (상하좌우로만 이동, 대각선 이동X)
~~~
A B C 
D E F
G H I
~~~

A에서 이동 가능한 경로는 B,D가 되며 D,B는 각각 A에서부터 1 거리다.
또 D,B 에서 이동 가능한 경로는 D(A,E,G) , B(A,E,C) 이다.
먼저 A는 방문 하였기 때문에 제외 하더라도 D(E,G) B(E,C) 가 각각 2의 거리가 된다. 
E로가는 경우의 수는 현재 2가이다.
이런식으로 각각 같은 거리에 위치한다면 결국 도착지 까지 이동한 거리가 최소거리가 된다.

----


# 깊이 우선 탐색
모든 Node를 탐색 하는 방법 중 하나이다. 주요 풀이 법(Stack, 재귀함수 호출)
`모든 경로를 파악 해야하는 경우 사용 (그림의 크기)`
----

# 백트레킹
DFS 변형 문제로 많이 출제 된다.
탐색은 DFS 방문했던 노드를 다시 방문하지 않았던 상태로 돌리는것이다.

2644 문제로 예시를 들자면

아래의 그래프가 있다고 가정하자
~~~
A B C D E 
B A C D E 
~~~
N(X,Y) 로 표시 할 경우 
A(0,0) 방문 후 B(0,1) 방문이 끝났다.
A(0,0) 방문 후 B(1,0) 을 방문 할 경우 B는 이미 방문된 노드이기 때문에 방문 할 수 없다. 
이런경우 최대 B라는 방문 노드를 다시 방문할수 있게 방문 체크를 해지해야한다. 

----

# 플로이드 워셜 
1926 문제 

최단 거리 / 단순히 경로를 찾는 문제 
각각의 모든 노드들의 최단거리를 찾기 때문에 
시간복잡도는 O(n^3)이 된다. (3중 포문)

서로의 거리가1이고 각각의 관계가 아래와 같다고 가정하자
A는 C,D 
B는 C
C는 D
D는 E

이것을 인접행렬로 나타낼 경우 아래와 같이 표현된다.
~~~
  A B C D E
A 0 0 1 1 0
B 0 0 1 0 0
C 1 1 0 1 1 
D 1 0 1 0 1
E 0 0 1 1 0
~~~

A의 베이컨 수는 
A->B 까지 도달하는 최소 거리는 
A,C,B로 2 거리가 된다.

A->C 까지 도달하는 최소 거리는 
A,C로 1거리가 된다.

A->D 까지 도달하는 최소 거리는 
A,C로 1거리가 된다.

A->E까지 도달하는 최소 거리는
A,D,E로 2거리가 된다.

이것을 B,C,D,E를 모두 구해 2중 배열로 출력하면 아래의 그래프가 된다.
이것이 플로이드 워셜 알고리즘 이다. 
~~~
  A B C D E
A 0 2 1 1 2 
B 2 0 1 2 3
c 1 1 0 1 2 
D 1 2 1 0 1
E 2 3 2 1 0
~~~


----
